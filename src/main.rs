#![no_std]
#![no_main]
#![feature(type_alias_impl_trait)]

// mod motor;

use defmt::*; // if info!() or other debug macros are used
use embassy_executor::Spawner;
use embassy_time::Timer;
use embassy_stm32::gpio::{AnyPin, Level, Output, OutputType, Pin, Speed};
use embassy_stm32::time::khz;
use embassy_stm32::timer::simple_pwm::{PwmPin, SimplePwm};
use embassy_stm32::timer::{Channel, OutputPolarity};
use embassy_stm32::usart::{Config, Uart};
use embassy_stm32::{bind_interrupts, peripherals, usart};
use embassy_stm32::peripherals::TIM1;
use heapless::String;
use core::fmt::Write;
use regex_automata::meta::Regex;

//noinspection RsUnusedImport
use {defmt_rtt as _, panic_probe as _};

use talc::*;

static mut ARENA: [u8; 10000] = [0; 10000];

#[global_allocator]
static ALLOCATOR: Talck<spin::Mutex<()>, ClaimOnOom> = Talc::new(unsafe {
    // if we're in a hosted environment, the Rust runtime may allocate before
    // main() is called, so we need to initialize the arena automatically
    ClaimOnOom::new(Span::from_const_array(core::ptr::addr_of!(ARENA)))
}).lock();






use core::sync::atomic::Ordering;
use atomic_float::AtomicF32;
static LED_SPEED_SHARE: AtomicF32 = AtomicF32::new(0.0);

// use core::sync::atomic::AtomicI16;

// static DUTY_A: AtomicI16 = AtomicI16::new(0);
// static DUTY_B: AtomicI16 = AtomicI16::new(0);

bind_interrupts!(struct Irqs {
    USART1 => usart::InterruptHandler<peripherals::USART1>;
});

#[embassy_executor::main]
/// Main function, blinks an LED for 200ms on, 300ms off, and prints the current loop number to the console.
async fn main(spawner: Spawner) {
    // Hardware objects
    let p = embassy_stm32::init(Default::default());

    let ch1 = PwmPin::new_ch1(p.PA8, OutputType::PushPull);
    let ch2 = PwmPin::new_ch2(p.PA9, OutputType::PushPull);
    let ch3 = PwmPin::new_ch3(p.PA10, OutputType::PushPull);
    let ch4 = PwmPin::new_ch4(p.PA11, OutputType::PushPull);
    
    let mut usart = Uart::new(p.USART1, p.PB7, p.PB6, Irqs, p.DMA2_CH7, p.DMA2_CH2, Config::default(),).unwrap();
    
    let mut pwm_a = SimplePwm::new(p.TIM1, Some(ch1), Some(ch2), None, None, khz(50), Default::default());
    // have to create a second instance of the timer to use the other channels with a separate pwm variable
    // this means using the .steal() method to create a second TIM1 instance out of thin air
    // which is an unsafe function but is safe to use in this context, as both PWM instances have the same parameters
    let mut pwm_b = SimplePwm::new(unsafe {TIM1::steal()}, None, None, Some(ch3), Some(ch4), khz(50), Default::default());
    
    
    // Variables
    // let mut duty: i16 = 50;
    let mut s: String<128> = String::new();

    // Functions
    pwm_a.set_polarity(Channel::Ch1, OutputPolarity::ActiveLow); // inverted PWM
    pwm_a.set_polarity(Channel::Ch2, OutputPolarity::ActiveLow);
    pwm_b.set_polarity(Channel::Ch3, OutputPolarity::ActiveLow);
    pwm_b.set_polarity(Channel::Ch4, OutputPolarity::ActiveLow);

    
    info!("Starting Program...");
    core::writeln!(&mut s, "Starting Program...\r").unwrap();
    unwrap!(usart.write(s.as_bytes()).await);
    s.clear();
    spawner.spawn(blinky(p.PC13.degrade())).unwrap();
    enable_motor(&mut pwm_a, 'a');
    enable_motor(&mut pwm_b, 'b');
    // set_motor_duty(&mut pwm_a, 'a', duty);
    // set_motor_duty(&mut pwm_b, 'b', duty*2);
    
    // Timer::after_secs(10).await;
    // disable_motor(&mut pwm_a, 'a');
    // disable_motor(&mut pwm_b, 'b');
    // info!("Program Ended, stopping motors.");
    // core::writeln!(&mut s, "Program Ended, stopping motors.\r").unwrap();
    // unwrap!(usart.write(s.as_bytes()).await);
    // s.clear();
    
    
    // UART Handling
    
    let re = Regex::new(r"M[1|2][0-9a-fA-f]{2}").unwrap();
    
    // const BACKSPACE: [u8; 1] = [8u8];
    // const DELETE: [u8; 1] = [127u8];
    let mut current_char: [u8; 1] = [0; 1];
    let mut msg: [u8; 4] = [0; 4];
    let mut index = 0usize;
    loop {
        unwrap!(usart.read(&mut current_char).await);
        if index > 2 {
            index = 3;
        }
        if (current_char[0] == 13) | (current_char[0] == 10) {
            // carriage return or line feed
            if index == 3 {
                let command = core::str::from_utf8(&msg).unwrap();
                if re.is_match(command) {
                    let motor = command.chars().nth(1).unwrap();
                    let duty = ((u8::from_str_radix(&command[2..], 16).unwrap() as i8) as i16)*100/128;
                    if motor == '1' {
                        set_motor_duty(&mut pwm_a, 'a', duty);
                    } else if motor == '2' {
                        set_motor_duty(&mut pwm_b, 'b', duty);
                    }
                    unwrap!(usart.write("\r\n".as_ref()).await);
                    core::writeln!(&mut s, "Motor {} set to {}%\r", motor, duty).unwrap();
                    unwrap!(usart.write(s.as_bytes()).await);
                    s.clear();
                    msg = [0; 4];
                    index = 0;
                } else {
                    unwrap!(usart.write("\r\n".as_ref()).await);
                    core::writeln!(&mut s, "Invalid Command\r").unwrap();
                    unwrap!(usart.write(s.as_bytes()).await);
                    s.clear();
                    msg = [0; 4]; // Clear the current input
                    index = 0;
                }
            }
        } else if (current_char[0] == 8) | (current_char[0] == 127) {
            // backspace
            if index > 0 {
                for n in index..msg.len() {
                    msg[n] = 0;
                }
                // msg[index] = 0;
                info!("Index: {}", index);
                if index < 4 {
                    index -= 1;
                }
                unwrap!(usart.write("\r    \r".as_ref()).await);
                unwrap!(usart.write(&msg).await);
            }
        } else {
            msg[index] = current_char[0];
            // info!("Current char: {}", current_char[0]);
            index += 1;
            unwrap!(usart.write("\r".as_ref()).await);
            // unwrap!(usart.write(&backspace).await);
            unwrap!(usart.write(&msg).await);
        }

    }

    // let mut msg: [u8; 1] = [0; 1];
    /*loop {
        usart.read(&mut msg).await.unwrap();
        usart.write(&msg).await.unwrap();
    }*/
}


#[embassy_executor::task]
async fn blinky(p: AnyPin) {
    let mut led = Output::new(p, Level::Low, Speed::Low);

    // let mut counter: usize = 0;
    
    // let scurve_duty: [f32; 1024] = [0.0013585194, 0.0013906909, 0.0014236233, 0.0014573344, 0.0014918426, 0.0015271666, 0.0015633256, 0.0016003394, 0.0016382283, 0.0016770125, 0.0017167135, 0.0017573526, 0.0017989521, 0.0018415345, 0.0018851229, 0.0019297409, 0.0019754132, 0.002022164, 0.002070019, 0.002119004, 0.0021691457, 0.0022204712, 0.0022730085, 0.0023267858, 0.0023818326, 0.0024381785, 0.002495854, 0.0025548902, 0.002615319, 0.0026771736, 0.002740487, 0.0028052935, 0.002871628, 0.0029395267, 0.0030090257, 0.003080163, 0.0031529765, 0.003227506, 0.003303791, 0.0033818735, 0.0034617945, 0.0035435979, 0.0036273268, 0.0037130273, 0.0038007444, 0.0038905258, 0.0039824196, 0.004076475, 0.0041727424, 0.0042712735, 0.004372121, 0.004475339, 0.004580982, 0.0046891076, 0.0047997725, 0.0049130367, 0.0050289603, 0.0051476047, 0.0052690334, 0.005393311, 0.0055205035, 0.005650679, 0.0057839057, 0.005920255, 0.006059799, 0.0062026116, 0.0063487682, 0.006498347, 0.0066514257, 0.0068080863, 0.0069684098, 0.0071324822, 0.00730039, 0.00747222, 0.007648063, 0.007828012, 0.008012161, 0.008200605, 0.008393445, 0.008590779, 0.008792712, 0.00899935, 0.009210797, 0.009427167, 0.009648568, 0.009875118, 0.010106932, 0.010344132, 0.010586839, 0.010835178, 0.011089277, 0.011349267, 0.011615282, 0.011887455, 0.012165929, 0.012450844, 0.012742344, 0.01304058, 0.013345701, 0.013657863, 0.013977223, 0.014303942, 0.014638185, 0.01498012, 0.015329917, 0.015687753, 0.016053805, 0.016428255, 0.01681129, 0.0172031, 0.017603878, 0.018013826, 0.018433137, 0.018862022, 0.019300688, 0.01974935, 0.02020823, 0.020677544, 0.021157524, 0.021648398, 0.022150403, 0.022663781, 0.023188774, 0.023725633, 0.024274614, 0.024835972, 0.025409974, 0.02599689, 0.02659699, 0.027210556, 0.027837874, 0.028479228, 0.029134916, 0.02980524, 0.030490497, 0.031191006, 0.031907078, 0.032639038, 0.03338721, 0.034151923, 0.03493352, 0.035732344, 0.03654874, 0.03738307, 0.038235687, 0.03910696, 0.03999726, 0.04090697, 0.041836463, 0.04278614, 0.043756384, 0.044747606, 0.045760207, 0.0467946, 0.0478512, 0.048930436, 0.050032727, 0.051158525, 0.05230825, 0.053482365, 0.05468131, 0.055905543, 0.057155535, 0.058431737, 0.05973463, 0.061064698, 0.062422417, 0.06380826, 0.06522273, 0.066666335, 0.06813956, 0.06964291, 0.07117689, 0.07274202, 0.07433881, 0.07596778, 0.07762945, 0.07932435, 0.081053, 0.08281594, 0.08461368, 0.08644678, 0.088315755, 0.09022115, 0.092163496, 0.09414334, 0.096161194, 0.098217614, 0.100313134, 0.102448285, 0.104623586, 0.10683959, 0.10909681, 0.11139576, 0.11373698, 0.11612097, 0.11854827, 0.12101932, 0.12353469, 0.12609482, 0.12870023, 0.13135138, 0.13404875, 0.13679276, 0.13958392, 0.14242262, 0.1453093, 0.14824437, 0.15122823, 0.15426129, 0.15734388, 0.1604764, 0.16365919, 0.16689251, 0.17017674, 0.17351213, 0.17689897, 0.18033749, 0.1838279, 0.18737045, 0.1909653, 0.19461258, 0.19831245, 0.20206502, 0.20587035, 0.20972852, 0.21363954, 0.21760342, 0.2216201, 0.22568953, 0.22981162, 0.23398627, 0.23821327, 0.2424925, 0.24682365, 0.25120655, 0.25564083, 0.2601262, 0.26466233, 0.26924872, 0.27388498, 0.27857068, 0.28330523, 0.28808814, 0.29291877, 0.29779655, 0.30272076, 0.30769074, 0.3127057, 0.31776488, 0.32286745, 0.3280126, 0.33319935, 0.33842686, 0.34369406, 0.34900004, 0.35434365, 0.35972393, 0.3651397, 0.37058973, 0.37607297, 0.3815882, 0.38713405, 0.39270934, 0.3983128, 0.40394297, 0.40959856, 0.4152782, 0.42098036, 0.42670372, 0.43244678, 0.43820804, 0.44398606, 0.44977924, 0.45558608, 0.461405, 0.46723446, 0.4730729, 0.4789187, 0.4847703, 0.49062604, 0.49648437, 0.50234365, 0.5082024, 0.51405877, 0.51991135, 0.5257584, 0.5315984, 0.5374298, 0.543251, 0.54906034, 0.5548564, 0.56063753, 0.56640226, 0.5721491, 0.5778765, 0.5835831, 0.5892673, 0.59492785, 0.6005632, 0.6061721, 0.6117531, 0.617305, 0.6228264, 0.62831616, 0.63377297, 0.6391956, 0.6445831, 0.6499342, 0.65524775, 0.6605228, 0.6657583, 0.6709533, 0.6761068, 0.68121797, 0.6862859, 0.6913098, 0.6962888, 0.70122224, 0.70610934, 0.7109495, 0.715742, 0.7204863, 0.72518176, 0.72982794, 0.73442435, 0.7389705, 0.7434661, 0.7479107, 0.7523038, 0.7566454, 0.76093495, 0.7651725, 0.76935756, 0.7734902, 0.77757025, 0.78159744, 0.7855719, 0.78949344, 0.7933622, 0.7971781, 0.8009412, 0.8046516, 0.80830944, 0.81191474, 0.8154677, 0.81896853, 0.8224174, 0.8258146, 0.8291602, 0.8324546, 0.8356982, 0.838891, 0.84203357, 0.84512615, 0.848169, 0.85116273, 0.85410756, 0.8570039, 0.85985214, 0.8626528, 0.86540616, 0.8681128, 0.87077314, 0.87338775, 0.8759569, 0.8784812, 0.88096106, 0.883397, 0.8857896, 0.88813937, 0.89044666, 0.89271224, 0.89493644, 0.8971199, 0.899263, 0.9013664, 0.90343064, 0.9054561, 0.9074436, 0.90939337, 0.9113061, 0.9131823, 0.9150225, 0.9168273, 0.91859716, 0.9203326, 0.9220342, 0.9237025, 0.925338, 0.92694116, 0.9285126, 0.93005276, 0.93156224, 0.93304133, 0.9344909, 0.9359111, 0.9373027, 0.938666, 0.9400015, 0.94130987, 0.94259125, 0.9438465, 0.94507587, 0.9462798, 0.9474589, 0.94861346, 0.949744, 0.95085096, 0.95193475, 0.9529959, 0.9540346, 0.9550516, 0.956047, 0.9570215, 0.95797527, 0.9589087, 0.9598223, 0.96071655, 0.96159154, 0.9624479, 0.9632858, 0.9641057, 0.9649081, 0.9656931, 0.96646124, 0.9672126, 0.9679478, 0.96866703, 0.96937066, 0.9700589, 0.97073215, 0.9713907, 0.97203493, 0.9726651, 0.9732814, 0.9738842, 0.9744737, 0.9750503, 0.9756141, 0.97616553, 0.97670484, 0.97723216, 0.9777478, 0.9782522, 0.9787452, 0.97922736, 0.9796988, 0.98015976, 0.9806104, 0.98105097, 0.9814819, 0.9819031, 0.9823148, 0.98271745, 0.983111, 0.9834959, 0.983872, 0.9842397, 0.98459923, 0.98495054, 0.985294, 0.98562986, 0.98595804, 0.98627883, 0.9865925, 0.9868989, 0.98719853, 0.98749137, 0.98777753, 0.9880574, 0.98833084, 0.988598, 0.9888592, 0.9891145, 0.9893639, 0.98960775, 0.9898461, 0.9900789, 0.9903065, 0.9905289, 0.99074626, 0.9909587, 0.9911663, 0.9913692, 0.99156743, 0.9917612, 0.9919505, 0.9921355, 0.99231625, 0.992493, 0.9926656, 0.9928342, 0.9929991, 0.9931601, 0.9933175, 0.9934714, 0.99362165, 0.99376845, 0.99391186, 0.9940521, 0.994189, 0.9943229, 0.9944537, 0.9945815, 0.99470633, 0.9948283, 0.99494755, 0.99506396, 0.99517775, 0.99528897, 0.9953976, 0.99864143, 0.9986093, 0.9985764, 0.99854267, 0.99850816, 0.99847287, 0.9984366, 0.9983997, 0.99836177, 0.998323, 0.99828327, 0.9982426, 0.998201, 0.9981585, 0.99811494, 0.9980703, 0.9980246, 0.9979778, 0.99792993, 0.997881, 0.9978308, 0.99777955, 0.997727, 0.9976732, 0.99761814, 0.9975618, 0.9975042, 0.9974451, 0.9973847, 0.99732286, 0.9972595, 0.99719465, 0.9971284, 0.9970605, 0.9969909, 0.9969199, 0.996847, 0.99677247, 0.99669623, 0.9966181, 0.99653816, 0.9964563, 0.9963727, 0.996287, 0.9961992, 0.9961094, 0.9960175, 0.9959235, 0.99582726, 0.9957287, 0.9956279, 0.99552464, 0.995419, 0.99531096, 0.99520016, 0.99508697, 0.99497104, 0.99485236, 0.99473095, 0.9946067, 0.99447954, 0.9943493, 0.99421614, 0.9940797, 0.99394023, 0.99379736, 0.9936512, 0.9935016, 0.99334854, 0.9931919, 0.9930315, 0.9928676, 0.99269956, 0.99252784, 0.99235195, 0.992172, 0.9919878, 0.99179935, 0.9916066, 0.99140924, 0.9912073, 0.9910006, 0.99078923, 0.99057287, 0.9903514, 0.9901248, 0.989893, 0.98965585, 0.9894132, 0.98916477, 0.9889107, 0.9886507, 0.9883847, 0.9881125, 0.9878341, 0.9875492, 0.98725766, 0.9869594, 0.98665434, 0.98634213, 0.9860227, 0.985696, 0.9853618, 0.9850198, 0.98467004, 0.98431224, 0.9839462, 0.98357177, 0.9831887, 0.9827969, 0.9823961, 0.98198617, 0.9815669, 0.981138, 0.98069936, 0.9802507, 0.9797918, 0.9793225, 0.97884244, 0.97835165, 0.9778496, 0.9773362, 0.9768113, 0.9762744, 0.9757254, 0.97516406, 0.97459, 0.974003, 0.973403, 0.9727894, 0.9721621, 0.9715208, 0.9708651, 0.9701947, 0.9695095, 0.968809, 0.96809286, 0.967361, 0.9666128, 0.9658481, 0.9650665, 0.9642677, 0.9634512, 0.962617, 0.9617643, 0.9608931, 0.96000266, 0.959093, 0.95816344, 0.9572139, 0.95624363, 0.9552524, 0.9542397, 0.9532054, 0.9521488, 0.9510695, 0.94996727, 0.9488415, 0.94769174, 0.94651765, 0.94531864, 0.94409436, 0.94284445, 0.9415682, 0.9402653, 0.9389352, 0.9375776, 0.9361917, 0.93477726, 0.9333336, 0.9318604, 0.93035704, 0.92882305, 0.92725796, 0.92566115, 0.92403215, 0.9223705, 0.92067564, 0.9189469, 0.917184, 0.91538626, 0.9135532, 0.9116842, 0.9097788, 0.9078364, 0.9058566, 0.90383875, 0.9017823, 0.8996868, 0.8975516, 0.8953763, 0.8931603, 0.89090306, 0.88860416, 0.88626295, 0.88387895, 0.88145167, 0.87898064, 0.8764652, 0.8739051, 0.87129974, 0.86864847, 0.86595124, 0.8632071, 0.86041605, 0.85757726, 0.8546906, 0.8517555, 0.84877163, 0.8457386, 0.842656, 0.8395235, 0.8363407, 0.83310735, 0.8298232, 0.8264878, 0.82310086, 0.8196624, 0.81617194, 0.81262946, 0.8090346, 0.8053873, 0.8016874, 0.7979349, 0.79412955, 0.79027134, 0.7863604, 0.7823965, 0.77837974, 0.77431035, 0.7701882, 0.7660136, 0.7617866, 0.7575074, 0.75317615, 0.7487933, 0.7443591, 0.73987365, 0.73533756, 0.73075116, 0.7261149, 0.72142917, 0.7166946, 0.7119117, 0.707081, 0.70220333, 0.6972791, 0.69230914, 0.6872942, 0.68223494, 0.6771324, 0.6719873, 0.6668005, 0.661573, 0.6563058, 0.65099984, 0.64565617, 0.6402759, 0.63486016, 0.6294101, 0.6239269, 0.61841166, 0.61286575, 0.60729045, 0.6016871, 0.5960569, 0.5904013, 0.5847216, 0.5790194, 0.57329607, 0.567553, 0.5617917, 0.5560137, 0.5502206, 0.54441375, 0.53859484, 0.5327653, 0.52692693, 0.5210811, 0.5152295, 0.5093738, 0.5035154, 0.4976561, 0.49179748, 0.48594105, 0.48008853, 0.47424144, 0.4684014, 0.46257, 0.45674884, 0.45093948, 0.44514343, 0.4393623, 0.43359753, 0.42785072, 0.42212328, 0.41641676, 0.41073248, 0.40507197, 0.3994366, 0.39382774, 0.38824674, 0.38269484, 0.3771734, 0.3716837, 0.36622685, 0.36080417, 0.35541672, 0.35006565, 0.3447521, 0.33947703, 0.33424154, 0.32904655, 0.323893, 0.31878185, 0.3137139, 0.30869004, 0.30371103, 0.2987776, 0.2938905, 0.28905037, 0.2842579, 0.2795136, 0.27481812, 0.2701719, 0.2655755, 0.2610293, 0.25653377, 0.25208923, 0.24769604, 0.24335451, 0.23906489, 0.23482741, 0.2306423, 0.22650968, 0.22242968, 0.21840245, 0.21442801, 0.21050641, 0.20663768, 0.20282178, 0.19905867, 0.19534828, 0.19169049, 0.18808517, 0.18453218, 0.18103135, 0.17758247, 0.17418534, 0.17083967, 0.16754523, 0.16430172, 0.16110888, 0.15796633, 0.15487377, 0.15183084, 0.14883716, 0.14589237, 0.14299604, 0.14014779, 0.13734716, 0.13459374, 0.1318871, 0.12922674, 0.12661223, 0.12404307, 0.1215188, 0.11903891, 0.11660292, 0.11421031, 0.111860566, 0.1095532, 0.107287675, 0.10506348, 0.10288007, 0.10073694, 0.098633535, 0.096569344, 0.09454381, 0.09255641, 0.090606615, 0.08869387, 0.08681765, 0.084977426, 0.08317265, 0.0814028, 0.07966733, 0.07796572, 0.07629745, 0.07466198, 0.0730588, 0.071487375, 0.069947205, 0.06843778, 0.06695857, 0.06550908, 0.06408883, 0.06269729, 0.06133399, 0.05999843, 0.058690146, 0.05740864, 0.056153446, 0.054924093, 0.05372013, 0.052541092, 0.051386517, 0.050255973, 0.049149014, 0.0480652, 0.047004107, 0.04596531, 0.044948384, 0.043952923, 0.042978514, 0.042024758, 0.041091256, 0.04017762, 0.03928347, 0.03840842, 0.037552103, 0.036714148, 0.035894193, 0.03509188, 0.034306865, 0.033538803, 0.03278735, 0.032052178, 0.03133295, 0.03062936, 0.029941073, 0.029267788, 0.0286092, 0.027965, 0.027334899, 0.026718607, 0.026115833, 0.025526306, 0.02494974, 0.024385873, 0.02383444, 0.023295179, 0.022767833, 0.022252154, 0.021747893, 0.021254811, 0.020772671, 0.020301241, 0.019840294, 0.019389605, 0.018948957, 0.018518133, 0.018096926, 0.017685125, 0.017282529, 0.01688894, 0.016504167, 0.016128013, 0.015760297, 0.0154008325, 0.015049442, 0.0147059485, 0.014370181, 0.01404197, 0.013721151, 0.013407563, 0.013101046, 0.012801445, 0.01250861, 0.01222239, 0.01194264, 0.011669218, 0.011401982, 0.011140798, 0.010885532, 0.01063605, 0.010392226, 0.010153936, 0.009921053, 0.00969346, 0.009471038, 0.009253672, 0.009041249, 0.008833659, 0.008630794, 0.008432548, 0.008238817, 0.008049501, 0.007864501, 0.00768372, 0.007507063, 0.007334437, 0.0071657533, 0.0070009204, 0.006839854, 0.006682467, 0.006528679, 0.0063784067, 0.0062315725, 0.0060880966, 0.0059479047, 0.0058109225, 0.005677077, 0.005546297, 0.005418513, 0.005293658, 0.0051716645, 0.0050524687, 0.004936006, 0.0048222146, 0.0047110347, 0.0046024057, ];

    loop {
        let speed = LED_SPEED_SHARE.load(Ordering::Acquire); // Get the current speed from the shared resource
        // info!("Speed: {}", speed);
        match speed {
            0.0 => {
                led.set_high();
                Timer::after_millis(20).await; // don't run this too fast
            },
            _ => {
                // NOTE: had to get rid of pulsing in favor of basic blinking to afford the CPU more time for USART
                /*let pos_width = scurve_duty[counter];
                let neg_width = 1.0 - pos_width;
        
                if pos_width > 0.01 {
                    led.set_low();
                }
                Timer::after_micros((pos_width * 1000.0/2.0 * speed) as u64).await;
                if pos_width < 0.97 {
                    led.set_high();
                }
                Timer::after_micros((neg_width * 1000.0/2.0 * speed) as u64).await;
        
                if counter == 1023 {
                    counter = 0;
                } else {
                    counter += 1;
                }*/
                led.set_low();
                Timer::after_millis((5000.0/speed) as u64).await;
                led.set_high();
                Timer::after_millis((5000.0/speed) as u64).await;
            }
        }
    }
}


// TODO: Put these in the motor.rs file
fn enable_motor(pwm: &mut SimplePwm<TIM1>, motor: char) {
    let channels = match motor {
        'a' => [Channel::Ch1, Channel::Ch2],
        'b' => [Channel::Ch3, Channel::Ch4],
        _ => [Channel::Ch1, Channel::Ch2], // TODO: Return an error instead of assuming motor a by default
    };

    pwm.enable(channels[0]);
    pwm.enable(channels[1]);
}

fn disable_motor(pwm: &mut SimplePwm<TIM1>, motor: char) {
    let channels = match motor {
        'a' => [Channel::Ch1, Channel::Ch2],
        'b' => [Channel::Ch3, Channel::Ch4],
        _ => [Channel::Ch1, Channel::Ch2], // TODO: Return an error instead of assuming motor a by default
    };

    pwm.disable(channels[0]);
    pwm.disable(channels[1]);
    set_motor_duty(pwm, motor, 0);
}

fn set_motor_duty(pwm: &mut SimplePwm<TIM1>, motor: char, duty: i16) {
    let clamped_duty = duty.clamp(-100, 100) as i32;
    let max = pwm.get_max_duty() as u32;

    let channels = match motor {
        'a' => [Channel::Ch1, Channel::Ch2],
        'b' => [Channel::Ch3, Channel::Ch4],
        _ => [Channel::Ch1, Channel::Ch2], // TODO: Return an error instead of assuming motor a by default
    };

    info!("Motor: {}", motor);
    info!("Clamped Duty: {}", clamped_duty);

    if duty == 0 {
        pwm.set_duty(channels[0], 0);
        pwm.set_duty(channels[1], 0);
    } else if duty <= 0 {
        pwm.set_duty(channels[0], 0);
        pwm.set_duty(channels[1], (clamped_duty.unsigned_abs()*max/100) as u16);
    } else {
        pwm.set_duty(channels[0], (clamped_duty.unsigned_abs()*max/100) as u16);
        pwm.set_duty(channels[1], 0);
    }
    match clamped_duty.unsigned_abs() {
        0 => LED_SPEED_SHARE.store(0.0, Ordering::Release), // Update the LED with the current speed
        // _ => LED_SPEED_SHARE.store(10.0 / (clamped_duty.unsigned_abs() as f32), Ordering::Release), // Update the LED with the current speed
        _ => LED_SPEED_SHARE.store(clamped_duty.unsigned_abs() as f32, Ordering::Release), // Update the LED with the current speed
    }
}